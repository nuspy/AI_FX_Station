
from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple, Union

import math
import numpy as np

from PySide6 import QtWidgets, QtCore
from PySide6.QtCore import Qt, QObject, Slot

import matplotlib
import matplotlib.dates as mdates
<<<<<<< HEAD
from matplotlib.axes import Axes
from matplotlib.backend_bases import MouseButton
from matplotlib.figure import Figure
from matplotlib.lines import Line2D
from matplotlib.patches import Circle, FancyArrowPatch
from matplotlib.text import Annotation
=======
import matplotlib.axes as mpla
from matplotlib.backend_bases import MouseEvent
from loguru import logger
from PySide6 import QtWidgets
>>>>>>> plugin_phase_NemoTron


<<<<<<< HEAD
Number = Union[int, float, np.number]
TsType = Union[int, float, np.datetime64]

@dataclass
class PatternEvent:
    name: str
    kind: str                 # "chart" | "candle"
    direction: Optional[str]  # "bull" | "bear" | None
    ts_start: TsType
    ts_end: TsType
    confirm_ts: Optional[TsType] = None
    target_price: Optional[float] = None
    info_html: Optional[str] = None


class PatternOverlayRenderer(QObject):
=======
# --------------- RENDERER ---------------------

class PatternDetailsDialog(QtWidgets.QDialog):
    def __init__(self, parent, event):
        super().__init__(parent)
        self.setWindowTitle(f"Pattern: {event.pattern_key}")
        lay = QtWidgets.QVBoxLayout(self)
        def lab(s): 
            l=QtWidgets.QLabel(s); l.setTextFormat(Qt.TextFormat.RichText); l.setWordWrap(True); return l
        fields = [
            ("Kind", getattr(event,'kind','')),
            ("Direction", getattr(event,'direction','')),
            ("Confirm", str(getattr(event,'confirm_ts',''))),
            ("Target", str(getattr(event,'target_price', None))),
            ("Failure", str(getattr(event,'failure_price', None))),
            ("Info", str(getattr(event,'info',{})))
        ]
        html = "".join([f"<p><b>{k}:</b> {v}</p>" for k,v in fields])
        lay.addWidget(lab(html))
        btn = QtWidgets.QPushButton("Chiudi"); btn.clicked.connect(self.accept)
        lay.addWidget(btn)

class PatternOverlayRenderer:
>>>>>>> plugin_phase_NemoTron
    """
    Matplotlib overlay that draws:
      - a thick semi-transparent light-blue line under price during formation window [ts_start, ts_end]
      - a circular badge at confirm_ts with pattern name (green bull, red bear)
      - optional target as dashed horizontal line and arrow from confirm to target
    It is tolerant to x being either epoch-ms integers or matplotlib date floats.
    """
    def __init__(self, parent_widget: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent_widget)
        self._parent_widget = parent_widget
        self._ax: Optional[Axes] = None
        self._canvas = None
        self._events: List[PatternEvent] = []
        self._artists: List[Any] = []
        self._hover_annot: Optional[Annotation] = None
        self._is_panning: bool = False
        self._x_mode: str = "auto"   # "ms_epoch" | "mdates" | "auto"
        self._mpl_cids: List[int] = []
        self._last_drawn_count: int = 0

    # ---------- Public API ----------
    def set_axes(self, ax: Axes, canvas=None) -> None:
        """Attach to an Axes and its canvas; safe to call multiple times."""
        self._disconnect_mpl_events()
        self._ax = ax
        self._canvas = canvas or ax.figure.canvas
        self._connect_mpl_events()

    def set_events(self, events: List[Dict[str, Any]], x_mode: str = "auto") -> None:
        """Accept list of dict or PatternEvent and schedule a redraw."""
        parsed: List[PatternEvent] = []
        for e in events or []:
            if isinstance(e, PatternEvent):
                parsed.append(e)
            else:
                parsed.append(PatternEvent(**e))
        self._events = parsed
        self._x_mode = x_mode or "auto"
        self.draw()

    # ---------- Internals ----------
    # Utilities
    def _disconnect_mpl_events(self) -> None:
        if self._canvas and self._mpl_cids:
            for cid in self._mpl_cids:
                try:
                    self._canvas.mpl_disconnect(cid)
                except Exception:
                    pass
        self._mpl_cids = []

    def _connect_mpl_events(self) -> None:
        if not self._canvas:
            return
        self._mpl_cids.append(self._canvas.mpl_connect("draw_event", self._on_draw))
        self._mpl_cids.append(self._canvas.mpl_connect("motion_notify_event", self._on_motion))
        self._mpl_cids.append(self._canvas.mpl_connect("button_press_event", self._on_press))
        self._mpl_cids.append(self._canvas.mpl_connect("button_release_event", self._on_release))
        self._mpl_cids.append(self._canvas.mpl_connect("pick_event", self._on_pick))

<<<<<<< HEAD
    def _clear_artists(self) -> None:
        for a in self._artists:
            try:
                a.remove()
=======
        def score(x):
            if np.isnan(x): return (False, np.inf)
            inside = (xmin <= x <= xmax)
            dist = abs(x - mid)
            return (inside, dist)

        in_date, d_date = score(x_date)
        in_ms, d_ms = score(x_ms)
        if in_date and not in_ms:
            x = x_date
        elif in_ms and not in_date:
            x = x_ms
        else:
            x = x_date if d_date <= d_ms else x_ms
        return x

    # ---------- Event normalization & density ----------
    def _pattern_label(self, e: object) -> str:
        # Prefer stable id, then human title from info provider
        cand_keys = ("name", "key", "pattern_name", "pattern", "label", "kind")
        raw = None
        for k in cand_keys:
            if isinstance(e, dict) and k in e and e[k]:
                raw = str(e[k]); break
            v = getattr(e, k, None)
            if v:
                raw = str(v); break
        if not raw:
            raw = type(e).__name__
        # Try to map to human-friendly title via info provider
        try:
            if getattr(self, "info", None):
                meta = None
                if hasattr(self.info, "get"):
                    meta = self.info.get(raw)
                if meta is None and hasattr(self.info, "get_info"):
                    meta = self.info.get_info(raw)
                if isinstance(meta, dict):
                    title = meta.get("title") or meta.get("name") or meta.get("label")
                    if title:
                        return str(title)
        except Exception:
            pass
        return raw

    def _direction_color(self, direction: str) -> str:
        d = str(direction or "").lower()
        if d in ("up", "bull", "bullish", "long", "buy"):
            return "#2ecc71"  # green
        if d in ("down", "bear", "bearish", "short", "sell"):
            return "#e74c3c"  # red
        return "#3498db"     # neutral

    def _normalize_events(self, ax: mpla.Axes, evs):
        norm = []
        for e in evs:
            label = self._pattern_label(e)
            ts = getattr(e, "confirm_ts", getattr(e, "ts", None))
            px = getattr(e, "confirm_price", getattr(e, "price", getattr(e, "target_price", None)))
            kind = getattr(e, "kind", "unknown")
            direction = getattr(e, "direction", "neutral")

            x = self._x_from_ts_safest(ax, ts)
            try:
                y = float(px) if px is not None else np.nan
            except Exception:
                y = np.nan

            if not np.isnan(x) and not np.isnan(y):
                norm.append((x, y, label, kind, direction, e))

        try:
            norm.sort(key=lambda t: float(t[0]), reverse=True)
        except Exception:
            pass
        return norm

    def _density_filter(self, ax: mpla.Axes, norm):
        kept = []
        picked_lbl = set()
        last_x_by_lbl: Dict[str, float] = {}
        try:
            xd = ax.lines[0].get_xdata()
            step = float(xd[-1]) - float(xd[-2]) if len(xd) > 2 else 1.0
        except Exception:
            step = 1.0

        for x, y, label, kind, direction, e in norm:
            if label not in picked_lbl:
                kept.append((x, y, label, kind, direction, e))
                picked_lbl.add(label); last_x_by_lbl[label] = x
            else:
                if abs(x - last_x_by_lbl.get(label, -1e18)) < max(step * MIN_SEP_BARS, 1.0):
                    continue
                last_x_by_lbl[label] = x
                kept.append((x, y, label, kind, direction, e))
            if len(kept) >= MAX_OVERLAYS:
                break
        return kept

    # ---------- Drawing ----------
    def _clear_all(self) -> None:
        for art in self._badges + self._arrows + self._formations:
            try: art.remove()
            except Exception: pass
        self._badges.clear(); self._arrows.clear(); self._formations.clear()
        self._artist_map.clear()
        if self._tooltip is not None:
            try: self._tooltip.remove()
            except Exception: pass
        self._tooltip = None
        self._last_hover_artist = None

    def _draw_badge(self, x: float, y: float, label: str, direction: str, event_obj: object) -> None:
        ax = self.ax
        color = self._direction_color(direction)
        ms = 9.0
        ln = ax.plot([x], [y], marker="o", markersize=ms, markerfacecolor=color,
                     markeredgecolor="black", markeredgewidth=0.8, zorder=120, picker=HIT_RADIUS_PX)[0]
        txt = ax.text(x, y, f" {label} ", color="white",
                      bbox=dict(boxstyle="round,pad=0.25", fc=color, ec="black", lw=0.6, alpha=0.95),
                      fontsize=9, va="bottom", ha="left", zorder=121)
        self._badges.extend([ln, txt])
        self._artist_map[ln] = event_obj
        self._artist_map[txt] = event_obj

    def _draw_target_arrow(self, x: float, y: float, direction: str, e: object) -> None:
        target = getattr(e, "target_price", None)
        if target is None:
            return
        try:
            ty = float(target)
        except Exception:
            return
        ax = self.ax
        color = self._direction_color(direction)
        dy = ty - y
        if abs(dy) < 1e-12:
            dy = 0.0001
        arr = ax.annotate(
            "", xy=(x, ty), xytext=(x, y),
            arrowprops=dict(arrowstyle="-|>", lw=1.2, color=color, shrinkA=0, shrinkB=0),
            zorder=119
        )
        lab = ax.text(x, ty, f"{ty:.5f}", fontsize=8, color=color,
                      va="bottom" if dy>0 else "top", ha="left",
                      bbox=dict(boxstyle="round,pad=0.2", fc="white", ec=color, lw=0.6, alpha=0.8),
                      zorder=119)
        self._arrows.extend([arr, lab])

    def _event_window(self, e: object):
        ax = self.ax
        if not ax: return None
        start = getattr(e, "start_ts", None) or getattr(e, "begin_ts", None) \
                or getattr(e, "left_ts", None) or getattr(e, "formation_start_ts", None)
        end   = getattr(e, "end_ts", None)   or getattr(e, "finish_ts", None) \
                or getattr(e, "right_ts", None) or getattr(e, "formation_end_ts", None)

        if start is None and end is None:
            confirm = getattr(e, "confirm_ts", None)
            lookback = getattr(e, "lookback", None) or getattr(e, "window", None)
            if confirm is None or lookback is None:
                return None
            x_c = self._x_from_ts_safest(ax, confirm)
            try:
                xd = ax.lines[0].get_xdata()
                if len(xd) >= 3:
                    step = float(xd[-1]) - float(xd[-2])
                else:
                    step = 1.0
            except Exception:
                step = 1.0
            x0 = x_c - step * float(lookback)
            x1 = x_c
            return (x0, x1)

        if start is None:
            start = getattr(e, "ts", None)
        if end is None:
            end = getattr(e, "confirm_ts", None) or getattr(e, "ts", None)

        if start is None or end is None:
            return None

        x0 = self._x_from_ts_safest(ax, start)
        x1 = self._x_from_ts_safest(ax, end)
        if not np.isfinite(x0) or not np.isfinite(x1):
            return None
        if x1 < x0: x0, x1 = x1, x0
        return (x0, x1)

    def _get_main_price_line(self):
        # Prefer the underlying price line from PlotService even if hidden
        try:
            ps = getattr(self.controller, "plot_service", None)
            pl = getattr(ps, "_price_line", None)
            if pl is not None and hasattr(pl, "get_xdata") and len(pl.get_xdata()) >= 2:
                return pl
        except Exception:
            pass
        ax = self.ax
        if not ax:
            return None
        try:
            if ax.lines:
                # pick the line with most points
                lines = [ln for ln in ax.lines if len(getattr(ln, "get_xdata", lambda:[])()) >= 2]
                if lines:
                    return max(lines, key=lambda ln: len(ln.get_xdata()))
        except Exception:
            pass
        return None

    def _draw_formation_segment(self, x_confirm: float, e: object) -> None:
        ax = self.ax
        if not ax:
            return
        win = self._event_window(e)
        if not win:
            return
        x0, x1 = win
        if not np.isfinite(x0) or not np.isfinite(x1) or x1 <= x0:
            return

        price_line = self._get_main_price_line()
        if price_line is None:
            # No vertical bands fallback: if price-line is unavailable, skip drawing
            return

        xd = np.asarray(price_line.get_xdata(), dtype=float)
        yd = np.asarray(price_line.get_ydata(), dtype=float)
        mask = (xd >= x0) & (xd <= x1)
        if mask.sum() < 2:
            return

        # Thicker than the price line and color by direction (green bull, red bear)
        try:
            base_lw = float(getattr(price_line, "get_linewidth", lambda: 1.2)())
        except Exception:
            base_lw = 1.2
        linewidth = max(base_lw * 1.8, base_lw + 1.5, 3.5)
        direction = getattr(e, "direction", None)
        color = self._direction_color(direction)
        z = max(price_line.get_zorder() - 1, 1)

        ln, = ax.plot(xd[mask], yd[mask],
                      color=color, linewidth=linewidth,
                      alpha=max(FORMATION_LINE_ALPHA, 0.5), zorder=z)
        self._formations.append(ln)

    # ---------- Interaction ----------
    def _bind_canvas_events(self) -> None:
        ax = self._resolve_axes()
        if not ax or not ax.figure:
            return
        canvas = ax.figure.canvas
        if self._cid_move is None:
            self._cid_move = canvas.mpl_connect("motion_notify_event", self._on_mouse_move)
        if self._cid_click is None:
            self._cid_click = canvas.mpl_connect("button_press_event", self._on_mouse_click)

    def _hit_test(self, event: MouseEvent) -> Optional[mpla.Artist]:
        if event.inaxes is not self.ax:
            return None
        if not self._badges:
            return None
        ax = self.ax
        ex, ey = event.x, event.y
        best = None
        best_d2 = HIT_RADIUS_PX**2 + 1
        for art in self._badges:
            try:
                if hasattr(art, "get_xdata"):
                    xdata, ydata = art.get_xdata(), art.get_ydata()
                    if len(xdata) != 1:
                        continue
                    x, y = float(xdata[0]), float(ydata[0])
                else:
                    x, y = art.get_position()
                px, py = ax.transData.transform((x, y))
                d2 = (px - ex)**2 + (py - ey)**2
                if d2 < best_d2:
                    best_d2 = d2; best = art
            except Exception:
                continue
        if best is not None and best_d2 <= HIT_RADIUS_PX**2:
            return best
        return None

    def _ensure_tooltip(self):
        if self._tooltip is None and self.ax:
            self._tooltip = self.ax.annotate(
                "", xy=(0, 0), xytext=(12, 12), textcoords="offset points",
                bbox=dict(boxstyle="round,pad=0.3", fc="black", ec="white", lw=0.6, alpha=0.85),
                color="white", fontsize=9, zorder=200
            )
            self._tooltip.set_visible(False)

    def _on_mouse_move(self, event: MouseEvent) -> None:
        ax = self.ax
        if not ax or event.inaxes is not ax:
            if self._tooltip and self._tooltip.get_visible():
                self._tooltip.set_visible(False)
                try: ax.figure.canvas.draw_idle()
                except Exception: pass
            return

        art = self._hit_test(event)
        self._ensure_tooltip()
        if art is None:
            if self._tooltip.get_visible():
                self._tooltip.set_visible(False)
                ax.figure.canvas.draw_idle()
            self._last_hover_artist = None
            return

        if art is self._last_hover_artist and self._tooltip.get_visible():
            return

        ev = self._artist_map.get(art)
        label = self._pattern_label(ev) if ev is not None else "pattern"
        self._tooltip.xy = (event.xdata, event.ydata)
        self._tooltip.set_text(str(label))
        self._tooltip.set_visible(True)
        self._last_hover_artist = art
        try: ax.figure.canvas.draw_idle()
        except Exception: pass

    def _on_mouse_click(self, event: MouseEvent) -> None:
        ax = self.ax
        if not ax or event.inaxes is not ax or event.button != 1:
            return
        art = self._hit_test(event)
        if art is None:
            return
        ev = self._artist_map.get(art)
        if ev is None:
            return
        opener = getattr(self.controller, "open_pattern_info", None)
        if callable(opener):
            try:
                opener(ev); return
>>>>>>> plugin_phase_NemoTron
            except Exception:
                pass
        self._artists.clear()
        if self._hover_annot is not None:
            try:
                self._hover_annot.remove()
            except Exception:
                pass
            self._hover_annot = None

    def _price_line(self) -> Optional[Line2D]:
        if not self._ax:
            return None
        # Heuristic: pick the longest visible Line2D (often the price line)
        lines = [l for l in self._ax.lines if l.get_visible()]
        if not lines:
            return None
        return max(lines, key=lambda l: len(l.get_xdata(orig=False)))

    def _axis_mode(self) -> str:
        if self._x_mode != "auto":
            return self._x_mode
        line = self._price_line()
        if line is None:
            return "ms_epoch"
        x = np.asarray(line.get_xdata(orig=False))
        if x.size == 0:
            return "ms_epoch"
        # mdates are floats roughly ~ 20000
        return "mdates" if (np.issubdtype(x.dtype, np.floating_) and x.mean() > 1000) else "ms_epoch"

    def _to_axis_x(self, ts: TsType) -> Optional[float]:
        if ts is None:
            return None
        mode = self._axis_mode()
        # ts can be pandas Timestamp -> convert to ms then to mdates if needed.
        if hasattr(ts, "value"):  # pandas Timestamp
            # value is ns since epoch
            ts_ms = int(int(ts.value) // 1_000_000)
        elif isinstance(ts, (np.integer, int)):
            ts_ms = int(ts)
        elif isinstance(ts, (float, np.floating)):
            # already an axis value in mdates perhaps
            return float(ts)
        else:
            try:
                ts_ms = int(ts)  # hope implicit cast
            except Exception:
                return None
        if mode == "mdates":
            return mdates.epoch2num(ts_ms / 1000.0)
        return float(ts_ms)

    def _y_at(self, x_query: float) -> Optional[float]:
        """Interpolate approximate price y on price line at x_query (axis units)."""
        line = self._price_line()
        if line is None:
            return None
        x = np.asarray(line.get_xdata(orig=False), dtype=float)
        y = np.asarray(line.get_ydata(orig=False), dtype=float)
        if x.size < 2:
            return None
        idx = np.searchsorted(x, x_query)
        idx = np.clip(idx, 1, x.size - 1)
        x0, x1 = x[idx - 1], x[idx]
        y0, y1 = y[idx - 1], y[idx]
        if x1 == x0:
            return float(y0)
        t = (x_query - x0) / (x1 - x0)
        return float(y0 + t * (y1 - y0))

    def _in_view_x(self, x: float) -> bool:
        if not self._ax:
            return False
        x0, x1 = self._ax.get_xlim()
        return (x >= min(x0, x1)) and (x <= max(x0, x1))

    def _badge_face(self, direction: Optional[str]) -> str:
        if direction == "bull":
            return "#2ecc71"  # green
        if direction == "bear":
            return "#e74c3c"  # red
        return "#95a5a6"      # gray

    def _draw_event(self, ev: PatternEvent) -> None:
        if not self._ax:
            return
        x_start = self._to_axis_x(ev.ts_start)
        x_end = self._to_axis_x(ev.ts_end)
        x_conf = self._to_axis_x(ev.confirm_ts) if ev.confirm_ts is not None else None

        if x_start is None or x_end is None:
            return
        if not (self._in_view_x(x_start) or self._in_view_x(x_end) or (x_conf is not None and self._in_view_x(x_conf))):
            # Skip drawing completely off-screen
            return

        # 1) Formation ribbon under price
        # draw by sampling price line between x_start..x_end
        line = self._price_line()
        if line is not None:
            x = np.asarray(line.get_xdata(orig=False), dtype=float)
            y = np.asarray(line.get_ydata(orig=False), dtype=float)
            mask = (x >= min(x_start, x_end)) & (x <= max(x_start, x_end))
            if mask.any():
                hl = Line2D(x[mask], y[mask], linewidth=3.5, color="#5dade2", alpha=0.35, zorder=1.0)
                self._ax.add_line(hl)
                self._artists.append(hl)

        # 2) Badge at confirmation with name
        if x_conf is not None:
            y_conf = self._y_at(x_conf) or (self._ax.get_ylim()[0] + self._ax.get_ylim()[1]) * 0.5
            circ = Circle((x_conf, y_conf), radius=0.0, transform=self._ax.transData)
            # Use annotate to get a filled rounded box
            color = self._badge_face(ev.direction)
            annot = self._ax.annotate(
                ev.name,
                xy=(x_conf, y_conf),
                xytext=(6, 12),
                textcoords="offset points",
                ha="left", va="bottom",
                fontsize=8,
                color="white",
                bbox=dict(boxstyle="round,pad=0.2", fc=color, ec="none", alpha=0.95),
                picker=True,
                zorder=5.0,
            )
            self._artists.extend([circ, annot])

        # 3) Target line + arrow
        if ev.target_price is not None and x_conf is not None:
            y_tgt = float(ev.target_price)
            tgt = self._ax.axhline(y_tgt, linestyle="--", linewidth=1.0, color="#7f8c8d", alpha=0.8, zorder=1.5)
            # arrow from confirmation to target
            y_conf = self._y_at(x_conf) or y_tgt
            col = "#27ae60" if (ev.direction == "bull") else "#c0392b"
            arr = FancyArrowPatch(
                (x_conf, y_conf), (x_conf, y_tgt),
                arrowstyle="-|>",
                mutation_scale=10,
                color=col,
                alpha=0.85,
                linewidth=1.2,
                zorder=2.0,
            )
            self._ax.add_artist(arr)
            self._artists.extend([tgt, arr])

    def draw(self, events: Optional[List[Dict[str, Any]]] = None) -> None:
        """Redraw overlay for current events; if events provided, replaces current first."""
        if events is not None:
            self.set_events(events)
            return
        if self._ax is None or self._canvas is None:
            return
        if self._is_panning:
            return  # don't redraw during pan, wait for release
        self._clear_artists()
        count = 0
        for ev in self._events:
            try:
                self._draw_event(ev)
                count += 1
                if count >= 80:
                    # Draw at most 80 badges for performance; prioritize recent (assumed last)
                    break
            except Exception:
                continue
        self._last_drawn_count = count
        try:
            self._canvas.draw_idle()
        except Exception:
            pass

<<<<<<< HEAD
    # ---------- Event handlers ----------
    def _on_draw(self, _evt=None) -> None:
        # ensure hover annotation is on top
        if self._hover_annot and self._hover_annot.get_visible():
            try:
                self._hover_annot.set_zorder(10.0)
            except Exception:
                pass

    def _on_press(self, evt) -> None:
        if evt.button == MouseButton.LEFT:
            self._is_panning = True

    def _on_release(self, evt) -> None:
        if evt.button == MouseButton.LEFT:
            self._is_panning = False
            # redraw after pan
            self.draw()

    def _on_pick(self, evt) -> None:
        # Clicking any badge annotation opens info dialog
        # We approximate by showing info for the closest event to x under cursor
        if not self._parent_widget or not self._events or evt.mouseevent is None:
            return
        x = evt.mouseevent.xdata
        if x is None:
            return
        chosen = None
        best = 1e18
        for ev in self._events:
            xc = self._to_axis_x(ev.confirm_ts) if ev.confirm_ts is not None else None
            if xc is None:
                continue
            d = abs(float(xc) - float(x))
            if d < best:
                best = d
                chosen = ev
        if chosen is None:
            return
        text = chosen.info_html or f"<b>{chosen.name}</b><br/>Pattern: {chosen.kind}<br/>Bias: {chosen.direction or '-'}"
        dlg = QtWidgets.QMessageBox(self._parent_widget)
        dlg.setIcon(QtWidgets.QMessageBox.Information)
        dlg.setWindowTitle(f"Pattern: {chosen.name}")
=======
        dlg = PatternDetailsDialog(getattr(self.controller, "window", None) or None)
        dlg.setWindowTitle(f"Pattern: {key}")
>>>>>>> plugin_phase_NemoTron
        dlg.setTextFormat(Qt.TextFormat.RichText)
        dlg.setText(text)
        dlg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        dlg.exec()

    def _on_motion(self, evt) -> None:
        if self._ax is None or evt.inaxes is None or evt.inaxes != self._ax:
            if self._hover_annot is not None:
                self._hover_annot.set_visible(False)
                try:
                    self._canvas.draw_idle()
                except Exception:
                    pass
            return
        x = evt.xdata
        if x is None or not self._events:
            return
        # show nearest event name within tolerance in pixels (~30px)
        tol_px = 30.0
        chosen = None
        best_px = 1e9
        for ev in self._events:
            xc = self._to_axis_x(ev.confirm_ts) if ev.confirm_ts is not None else None
            if xc is None:
                continue
            # data->pixel distance
            try:
                x_px, y_px = self._ax.transData.transform((xc, self._y_at(xc) or 0.0))
                d = abs(x_px - evt.x)
                if d < best_px and d <= tol_px:
                    best_px = d
                    chosen = ev
            except Exception:
                continue
        if chosen is None:
            if self._hover_annot is not None:
                self._hover_annot.set_visible(False)
                try:
                    self._canvas.draw_idle()
                except Exception:
                    pass
            return
        label = chosen.name
        if self._hover_annot is None:
            self._hover_annot = self._ax.annotate(
                label, xy=(evt.xdata, evt.ydata), xytext=(10, 10), textcoords="offset points",
                bbox=dict(boxstyle="round,pad=0.2", fc="#34495e", ec="none", alpha=0.85),
                color="white", fontsize=8, zorder=10.0, visible=True)
        else:
            self._hover_annot.set_text(label)
            self._hover_annot.xy = (evt.xdata, evt.ydata)
            self._hover_annot.set_visible(True)
        try:
            self._canvas.draw_idle()
        except Exception:
            pass
